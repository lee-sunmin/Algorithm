
백준알고리즘

BFS 인생문제 - Queue
이 문제 풀고 BFS 감 잡을 수 있었음 :)

마지막 visit [][] = true 
잘못 써서 시간초과 발생 했었음.
==================================

import java.util.*;

public class Main {
	static Node minNode;
	static Node sharkNode;

	static int[] dx = { 1, 0, -1, 0 };
	static int[] dy = { 0, -1, 0, 1 };
	static int[][] map;
	static boolean[][] visit;
	static int N;
	static int shark;
	static int total;
	static int result;

	static Queue<Node> queue;

	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		N = scan.nextInt();
		map = new int[N][N];
		visit = new boolean[N][N];
		queue = new LinkedList<Node>();

		shark = 2;
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < N; j++) {
				map[i][j] = scan.nextInt();
				if (map[i][j] == 9) {
					sharkNode = new Node(i, j, 0);
				}
			}
		}

		while (search()) {
			result += minNode.cnt;
			total++;
			map[sharkNode.x][sharkNode.y] = 0;
			sharkNode.x = minNode.x;
			sharkNode.y = minNode.y;

			if (total == shark) {
				shark++;
				total = 0;
			}
			map[sharkNode.x][sharkNode.y] = 9;
		}
		System.out.println(result);
	}

	public static boolean search() {

		queue.add(sharkNode);
		minNode = new Node();
		visit = new boolean[N][N];

		boolean state = false;
		while (!queue.isEmpty()) {
			Node temp = queue.poll();
			int x = temp.x;
			int y = temp.y;
			int cnt = temp.cnt;

			// this line can save the time
			if (minNode.cnt != -1 && minNode.cnt < cnt) {
				queue.clear();
				continue;
			}

			visit[x][y] = true;
			for (int i = 0; i < 4; i++) {
				int tx = x + dx[i];
				int ty = y + dy[i];
				if (tx >= 0 && ty >= 0 && tx < N && ty < N) {
					if (map[tx][ty] <= shark && map[tx][ty] != 9 && !visit[tx][ty]) {
						// If remove this line, run the time out
						visit[tx][ty] = true;
						queue.add(new Node(tx, ty, cnt + 1));

						if (map[tx][ty] < shark && map[tx][ty] != 0) {
							if (minNode.cnt == -1) {
								minNode = new Node(tx, ty, cnt + 1);
							} else if ((minNode.x > tx || (minNode.x == tx && minNode.y > ty))
									&& minNode.cnt >= cnt + 1) {
								minNode = new Node(tx, ty, cnt + 1);

							}
							state = true;
						}
					}
				}
			}
		}
		return state;
	}
}

class Node {
	int x;
	int y;
	int cnt;

	Node() {
		this.x = -1;
		this.y = -1;
		this.cnt = -1;
	}

	Node(int x, int y, int cnt) {
		this.x = x;
		this.y = y;
		this.cnt = cnt;
	}
}

2019 카카오 무지의 먹방라이브 효율성
진행 중

참고한 블로그 : http://ithub.tistory.com/34     <감사합니다>

=====================================================


	public static int solution(int[] food_times, long k) {
		HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
		long sum = 0;
		for (int i = 0; i < food_times.length; i++) {
			map.put(i, food_times[i]);
			sum = sum + food_times[i];
		}

		if (sum <= k)
			return -1;

		Iterator<Integer> it = sortByValue(map).iterator();
		int mapSize = map.size();
		long a = 0;
		long a2 = 0;
		while (it.hasNext()) {
			Integer temp = (Integer) it.next();
			a = map.get(temp) * mapSize;
			if (a <= k) {
				map.remove(temp);
				a2 = a;
			} else {
				k = k - a2;
				break;
			}
//			System.out.println(temp + " = " + map.get(temp));
		}

		mapSize = map.size();

		Iterator<Integer> iteratorKey = map.keySet().iterator(); // value값 오름차순
		ArrayList<Integer> keyList = new ArrayList<Integer>();
		while (iteratorKey.hasNext()) {
			Integer value = iteratorKey.next();
			keyList.add(value);
		}

		if (keyList.size() == 0) {
			return -1;
		} 
			return keyList.get((int) k % mapSize) + 1;
	}
	
	public static List<Integer> sortByValue(final Map<Integer, Integer> map) {
		List<Integer> list = new ArrayList<Integer>();
		list.addAll(map.keySet());
		Collections.sort(list, new Comparator<Object>() {
			public int compare(Object o1, Object o2) {
				Object v1 = map.get(o1);
				Object v2 = map.get(o2);
				return ((Comparable) v2).compareTo(v1);
			}
		});
		Collections.reverse(list); // 주석시 오름차순
		return list;
	}

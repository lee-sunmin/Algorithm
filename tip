강의 자료 요약

[모든 경로 탐색]

2015 선발 문제
소수 판별하기, 하노이탑

2016~2018  brute force ( 거친탐색 )
컴퓨터 연산으로 모든 곳을 방문해야 하는 것, 사람이 x
<<컴퓨터 능력 활용 관점>>

1.
재귀함수 활용 완전탐색
비재귀함수 활용한 완전탐색
(구조적으로 재귀를 쓰지 않으면 못푸는게 있으니까, 두개를 잘 나누는게 필요함)

재귀함수 이해하고 푸는 사람이 5% 정도 밖에 안된다.

2.
STL 사용을 허용한다.

3.
2문제가 출제되며, 1문제는 구현(재귀함수x, 반복문 등 규칙 찾아서), 
1문제는 완전탐색(그래프 문제.. dfs-90%.. 스택보다 재귀가 훨 편함.. 백트래킹 문제, bfs)

4.
시간복잡도, 공간복잡도 중요시함

n의 숫자가 작으면 높은 확률로 모든 경우를 다 하라는 말
n의 숫자가 크면 완전탐색 문제가 아닐 수 있음..ㅠ

1부터 45번까지, 6개를 뽑는 모든 경우의 수를 구하는 문제 - 비재귀
6개로 고정되어 있으니까, 그냥 6중 포문 쓰면 됨
** 고정 -> 재귀 ㄴㄴ

n개의 숫자 중 m개를 골랐을 때 나올 수 있는 모든 경우 출력 - 재귀 활용 안하면 못품 - 치킨배달 문제
뽑아야 하는 갯수가 변형이 되면 꼭 재귀를 써야 한다고 생각 (입력에 따라 반복문 구조가 바뀌는가?)


[순열 구하기] 5%

a~g 중에 4 입력하면 a~d 까지 써서 모든 경우 출력 4,2 (a~d안에서 2개 골라서 모든 경우의 수)
= (같은 문제라고 생각) 치킨배달

4개중에 3개의 치킨을 살렸을때
-> 전형적인 재귀함수 문제

###########################
드래곤 커브
규칙이 나오고 움직이는 방향이 주어짐. (오른쪽 : 1)

1
1 2
1 2 3 2   (1,2를 뒤집어서 1씩 증가시키면 3,2)
1 2 3 2 3 4 3 2 ..

이렇게 1,2,3세대 거슬려 올라가는 것들은 최대한 수열로 나타내기! (규칙 찾기)

point!!!!@@ 재귀함수를 쓰는가 안쓰는가 정하기
수열 함수 찾기

#######
회전판 문제 
상반기 기출문제 분석한 것
시뮬레이션 코드는 그냥 시키는대로만 짜는것
2개 조심!
구현(시뮬레이션)문제는 1) 초기화 2) 예외처리.. 빙고일 때, 갑자기 여러개 빙고 터지는 경우

맵을 주고 따라가는 문제에 대해서는, 배열 번지 참조 조심!! 상하좌우를 보면, 왼쪽위를 0,0......일때 위로가면 음수번지
** 버퍼 두르고 진행하는게 좋음 **

1개 int에 4바이트.. 스택메모리 1mb면, 스택 1000 * 1000 잡으면 오버플로우
힙매모리는 동적할당
정적메모리는 메인함수 위에 정적
알고리즘 할 때는, 그냥 다 전역변수로 만들어놓고 시작하는게 좋음

굳이 메모리 타이트하게 할 필요 없음

#######
1번 집에서 2번 집으로 갈 때, 밟았던 숫자는 하나만 밟을 수 있음

경로 최대 몇가지? 최대값?
경로를 찾는 문제는 거의 dfs라고 보면 됨. 밟았던 숫자는 또 못밟기 때문임..
bfs는 절대 못풀고 dfs임

bfs는 밟았던 숫자 또 밟을 수 있고, 출발점에서 끝점까지! 장애물 있음
백트래킹 할 때, 밟았다가 돌아가면 안밟았다고 체크 해줘야 함. visited..

#######
보호필름
m개중에 n개를 뽑는.. 유형중에 정답률 제일 낮음
근데 이거랑 치킨배달부 문제랑 굉장히 유사

어떤 집을 살릴지(어떤 곳에 약품을 투입할지)
모든 경우를 찾아냄

######
재귀함수의 시간복잡도
5가지, 5개
5^5

-
재귀함수보다 비재귀가 더 많음?


########
디저트 카페라는 문제 꼭 풀어보기

로또문제 관점으로 봐야 한다.
a랑 b 선분만 알고 있으면, 모든 경우 탐색 가능
시작점만 바꾸면서 가능한 a,b의 모든 경우를 돌려보면 됨
길이만 모든 쌍으로 알 수 있으면, 모든 점에 대해 돌려볼 수 있음

쌍을 찾고, 모든 사각형을 만든다 - 포인트

결론 : 재귀 아님

20으로 5승해도 320만밖에 안돼.
연산량 - 1억번에 1초라고 잡으면 된다. 몇백만 정도는 괜찮다.

#########
등산로 조성

모~든경로 다 찾는건, 시뮬레이션 안돼
하지만 이건 최단거리를 찾는게 아니고, dfs임! (다른 알고리즘으로는 풀기 힘들어)

dfs안에서 산 깎으면 너무 복잡해짐.

비효율적으로 해도 정확한 로직이 나오는게 중요

산 높이가 아무리 많아봣자 8*8
안깎아보고 dfs
1깎아보고 dfs
2깎아보고  dfs
.. dfs 들어가기 전에 한 좌표씩 돌면서 하나씩 깎아보는고.. 반복문 돌면서!
이렇게 하면 모든 경우에서 dfs 할 수 있음

반복문에서 해결할 수 있는건 다 해결해 놓고 , dfs 돌리자!

‘최대’ k만큼이니까, 안깎을수도 있고 1만 깎을 수도 있고 등
문제 확인할 때, k개라는게 정확히 뭔지 잘 정의

로직 설계를 완전 꼼꼼하게 하고!! 디버깅을 하지 말자
코드 풀기 전에 다 정리해 놓고 그대로 옮기는 것!

############
dfs의 정확성
정말 순회? 
두번 이상 방문 ㄴ? 모든 정점 방문?

나 방문
모든 이웃에게 물어봄

시간 복잡도는 O(V+E)

############
시간복잡도는 최악으로
12*12 짜리가 있으면, 12^2만큼 정점이 생기고, 한 정점은 4개..

#############
재귀함수 활용? 활용 ㄴ?

재귀함수 활용 ㄴ면, 
규칙 찾기
잘 따라 가기

재귀함수 활용 ㅇ면,
n개중에 m개 뽑기
모든 경로 찾아서 한 경로에 대한 최댓값 - dfs

미로찾기는 무조껀 bfs 가까운곳부터 찾음 (출발점에서 가까운 곳 부터)
dfs쓰면 가보지 않아도 될 경로를 너무 많이 가봄(너무너무 모든 경로. 시간제한 벗어날 수 있음)

한 경로에 대한 특정 조건이 붙는건 dfs!

(?) 모든 경우를 가장 단순하게 탐색하는 경우?
좀 무식해도 되니까 진짜 모든 경우를 빼먹지 않고 반복하는 방법 찾기!!

#########

인접행렬 / 인접리스트

인접 리스트가 더 좋음 :)
인접리스트로 할 때, 케이스가 잘 고려되지 않는 경우가 있음

#########
조건이 가장 작은 데이터일때랑,
가장 큰 데이터일때는 꼭 입력. 돌아가는지 아닌지 알 수 있음

설계의 취지 : 디버깅 안하기 위해서

산을 0~k만큼 깎는다(문제에서는 최대 k라고 했음)
깎고 나서, 산 봉우리를 시작점으로 dfs 돌린다
돌리는 과정에서 최대 값 저장
산 복원시킨 후 2. 반복

이런식으로.
생략하지 말고 가장 디테일하게 함. 애매한 부분일수록 디테일하게 정리해야 함.
다 적어놓고, 이걸 보고 그대로 번역
조심해야 할 조건 중간중간 추가

##########

[그 외]
카ㅇㅇ는 문자열처리가 12문제중에 10문제

++
Yoon’s Thinking

조건이 많고 깊숙히 들어갈 때마다
조건을 여러번 도는건 거의 bfs라고 생각하면 된다.
